package slp;

import java_cup.runtime.*;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens;
	
	private Lexer lexer;

	public Parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	public int getLine() {
		return lexer.getLineNumber();
	}
	
	public void syntax_error(Symbol s) {
		Token tok = (Token) s;
		System.out.println("Line " + tok.getLine()+": Syntax error; unexpected " + tok);
	}
:}

// This is just for debugging
scan with {:
	Token t = lexer.next_token();
	if (printTokens)
		System.out.println(t.getLine() + ":" + t);
	return t; 
:};

terminal READI;
//terminal PRINT;
terminal Integer NUMBER;
terminal String VAR;		// == ID (called this way in spec.)
terminal String CLASS_ID;
terminal UMINUS;
terminal PLUS;
terminal ASSIGN;
terminal BOOLEAN;
terminal BREAK;
terminal CLASS;
terminal COMMA;
terminal CONTINUE;
terminal DOT;
terminal EQUAL;
terminal EXTENDS;
terminal ELSE;
terminal FALSE;
terminal GT;
terminal IF;
terminal INT;
terminal LAND;
terminal LB;
terminal LPAREN;
terminal LCBR;
terminal LENGTH;
terminal NEW;
terminal LNEG;
terminal LOR;
terminal LT;
terminal MINUS;
terminal MOD;
terminal NEQUAL;
terminal NULL;
terminal RB;
terminal RCBR;
terminal RETURN;
terminal RPAREN;
terminal SEMI;
terminal STATIC;
terminal STRING;
terminal QUOTE;
terminal THIS;
terminal TRUE;
terminal VOID;
terminal WHILE;
terminal ID;
terminal MULT;
terminal DIV;
terminal GE;
terminal LE;


non terminal program;
non terminal classDecl;
non terminal classDeclList;
non terminal field;
non terminal method;
non terminal methodDecl;
non terminal fieldMethodList;
non terminal idList;
non terminal formal;
non terminal formalList;
non terminal location;
non terminal Expr expr;
non terminal Stmt stmt;
non terminal StmtList stmt_list;
non terminal Type type;
non terminal id;
non terminal call;
non terminal virtualCall;
non terminal staticCall;
non terminal literal;
non terminal composedExpr;
non terminal binop;
non terminal unop;



precedence left LOR;
precedence left LAND;
precedence left EQUAL, NEQUAL;
precedence left GT, LT, GE, LE;
precedence left PLUS, MINUS;
precedence left DIV, MULT, MOD;
precedence left UMINUS;
precedence left LB, DOT;
precedence left ELSE;



start with program;

program ::= classDeclList:cdl
{:
	RESULT= cdl;
	System.out.println("Reduced rule 'classDeclList');
}:
 | 
 {:
	RESULT= "";
	System.out.println("Reduced rule '' (empty program);
}:
;

classDeclList ::= classDeclList:cdl classDecl:cd
{:
	cdl.add(cd); RESULT= cdl;
	System.out.println("Reduced rule 'classDeclList COMMA classDecl');
:} | 
classDecl:c {:
		RESULT= new List<Class> (c);
		System.out.println("Reduced rule 'classDecl'");
:}
;

classDecl ::= CLASS CLASS_ID:cid LCBR fieldMethodList:fml RCBR 
			{: 
				RESULT= new Class (cid, fml);
				System.out.println("Reduced rule: CLASS CLASS_ID LCBR fieldMethodList RCBR");
			:} |
			CLASS CLASS_ID:cid EXTENDS CLASS_ID:ecid LCBR fieldMethodList:fml RCBR
			{:
				RESULT= new Class (cid, ecid, fml);
				System.out.println("Reduced rule: CLASS CLASS_ID EXTENDS CLASS_ID 
									LCBR fieldMethodList RCBR");
			:}
;


fieldMethodList ::= field:f fieldMethodList:fmList  {:
				fmList.addFieldMethod(f); RESULT = fmlist; 
				System.out.println("Reduced rule: field fieldMethodList");
		:} |
		method:m fieldMethodList:fmList {:
				fmList.addFieldMethod(m); RESULT = fmlist; 
				System.out.println("Reduced rule: method fieldMethodList");
		:} |
  		 field:f {:
		 	RESULT = new FieldMethodList(f);
		 	System.out.println("Reduced rule: field");
		 :}	 |
		 method:m {:
		 	RESULT = new FieldMethodList(m);
		 	System.out.println("Reduced rule: method"); 
		 :}	 
  ; 

field ::= type idList SEMI 
	{:
	RESULT= new Field(t, idList);
	System.out.println("Reduced rule 'type idList SEMI' ");
	:}
;



idList ::= idList:idl COMMA VAR:v 
	{:
	idl.add(v); RESULT= idl;
	System.out.println("Reduced rule 'idList COMMA VAR');
	:} |
	VAR:v
	{:
		RESULT= new List<VarExpr> (v);
		System.out.println("Reduced rule ' VAR');		
	:}  
;

method ::= STATIC methodDecl:m
{:
	m.isStatic=true; RESULT=m;
	System.out.println("Reduced rule 'STATIC methodDecl');
:} 
  	| methodDecl:m  
{:
	m.isStatic=false; RESULT=m;
	System.out.println("Reduced rule 'methodDecl');

:}
;

methodDecl ::= formal:f LPAREN formalList:frmls RPAREN LCBR stmt_list:slist RCBR
		{:
			RESULT = new Method (f, frmls, slist);
			System.out.println("Reduced rule 'STATIC typeVoid:tv VAR:method_name 
								LPAREN formals:frmls RPAREN LCBR stmt_list:slist RCBR' ");
		:} 
		| VOID id:method_name LPAREN formalList RPAREN LCBR RCBR
		{:
			RESULT = new Method (null, frmls, slist);
			System.out.println("Reduced rule 'typeVoid VAR 
								LPAREN formals RPAREN LCBR stmt_list RCBR' ");
		:} 
;

formal ::= type:t VAR:v
	{: 
		RESULT=new Formal (t,v);
		System.out.println("Reduced rule 'type VAR' ");
	:}
;

formalList ::=  formal |
	 formalList:fList COMMA type:t VAR:v {:
		 fList.addFormal(new Formal (t,v); RESULT = fList; 
		 System.out.println("Reduced rule 'formals COMMA type VAR' ");
	 :}
;

type ::= INT
		{:
			RESULT = new Type ("int");
			System.out.println("Reduced rule 'int' ");
						
		:} | 
		BOOLEAN {:
			RESULT = new Type ("boolean");
			System.out.println("Reduced rule 'boolean' ");
			
		:} |
		STRING
		{:
			RESULT = new Type ("string");
			System.out.println("Reduced rule 'string' ");
			
		:} | 
		 CLASS_ID {:
			RESULT = new Type ("class_id");
			System.out.println("Reduced rule 'CLASS_ID' ");
			
		:} | 
		 type:t LB RB{:
		 	RESULT = new Array(t);
			System.out.println("Reduced rule 'type LB RB' ");	
		 :}
;

stmt_list ::= stmt:s
	{: RESULT = new StmtList(s); :}
	| stmt_list:sl stmt:s
	{: sl.addStmt(s); RESULT = sl; :}
	
;

//Statement



stmt ::= 

	//assign statement
	//TODO : generalize to "location = expr" instead of var (==id).
	//VAR:v ASSIGN expr:e SEMI
	//{: VarExpr ve = new VarExpr(v); RESULT = new AssignStmt(ve, e); :}
	
	//print statement
	//| PRINT LPAREN expr:e RPAREN SEMI
	//{: RESULT = new PrintStmt(e); :}
	

	location:l ASSIGN expr:e SEMI
	{:
	RESULT = new LocationStatement(l, e);
	System.out.println("Reduced location=expr; for location ="+l +" and expr="+e);	
	:}
	
	 | call:c SEMI
	 {:
	 RESULT = new CallStatement(c);
	 System.out.println("Reduced call; for call ="+c);
	 :}
	 
	 | RETURN SEMI
	 {:
	 RESULT = new ReturnVoidStatement();
	 System.out.println("Reduced return;"); 
	 :}
	 
	 | RETURN expr:e SEMI
	 {:
	 RESULT = new ReturnStatement(e);
	 System.out.println("Reduced return e; for e ="+e);
	 :}
	 
	 | IF LPAREN expr:e RPAREN stmt:s
	 {:
	 RESULT = new SimpleIf(e, s);
	 System.out.println("Reduced if (e) stmt, for e ="+e+" and s ="+s);
	 :}
	 
	 | IF LPAREN expr:e RPAREN stmt:s1 ELSE stmt:s2
	 {:
	 RESULT = new If(e, s1, s2);
	 System.out.println("Reduced if (e) s1 else s2, for expr ="+e+" and stmt1 ="+s1+" and s2 ="+s2);
	 :} 
	 
	 | WHILE LPAREN expr:e RPAREN stmt:s
	 {:
	 RESULT = new WhileStatement(e,s);
	 System.out.println("Reduced while (e) s for e ="+e+" and s ="+s);
	 :}
	 
	 | BREAK SEMI
	 {:
	 RESULT = new BreakStatement();
	 System.out.println("Reduced break;");
	 :}
	 
	 | CONTINUE SEMI
	 {:
	 RESULT = new ContinueStatement();
	 System.out.println("Reduced continue;");
	 :}
	 
	 | LCBR stmt:s RCBR
	 {:
	 RESUTL = new BlockStatement(s);
	 System.out.println("Reduced {s} for s="+s);
	 :}
	 
	 | type ID:i SEMI
	 {:
	 RESULT = new SimpleTypeStatement(i);
	 System.out.println("Reduced type i; for i="+i);
	 :}
	 
	 | type ID:i EQUAL expr:e SEMI
	 {:
	 RESULT = new TypeStatement(i,e);
	 System.out.println("Reduced type i=e; for i="+i+" and e ="+e);
	 :}
	
;



//Expression
expr ::= 

		//Expression: "location" rule
		location
		
		//Expression: "call " rule
		| call 

		//Expression: "This" rule
		|	THIS:th
		{: 	RESULT = new VarExpr ("this");
			System.out.println("Reduced rule 'this' ");
		:}
		
		//Expression: new single instance of object.
		//syntax : new CLASS '(' ')'
		//example : new Student ()
		|	NEW:nw CLASS_ID:cl_id LPAREN:lp RPAREN:rp
		{:
			RESULT = new NewVarExpr(cl_id);
			System.out.println("Reduced rule 'new' for class " + cl_id);
		:}
		
		//Expression: new array instance of object.
		//syntax : new type '[' expr ']'
		//example : new Student [5]
		|	NEW:nw type:tp LB:lb expr:e1 RB:rb
		{:
			RESULT = new NewVarExpr(tp.toString(), e1);
			System.out.println("Reduced rule 'new array instance'"
			+ " for type " + tp.toString() + ", " 
			+ "array size expression: " + e1.toString());
		:}
				
		//Expression: length field.
		//expr '.' length
		//| expr:e1 DOT:dt LENGTH:ln
		|expr_dot: e LENGTH: ln
		{:
			RESULT = new ExprBase ();
			System.out.println ("Reduced rule 'length' for expr: " + e1 ) ;
		:}
		
		
		//Expression: binary ops.
		|	expr:e1 binop:op expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, op);
		   System.out.println("Reduced rule e1 "+op+" e2 for e1=" + e1 + " and e2="+e2);
		 :}

		//|	expr:e1 PLUS:p expr:e2
		//{: RESULT = new BinaryOpExpr(e1, e2, Operator.PLUS);
		//   System.out.println("Reduced rule e1 + e2 for e1=" + e1 + " and e2="+e2);
		// :}


		//Expression: Unray operarion
		| MINUS expr:e1
		{: RESULT = new UnaryOpExpr(e1, Operator.MINUS); :} %prec UMINUS

		| LNEG expr:e1
		{: RESULT = new UnaryOpExpr(e1, Operator.LNEG); :}


		//Expression: literal
		| literal
		
		//Expression between parens.
		| LPAREN expr:e RPAREN
		{: RESULT = e; :}
		

		//readi expression  (don't know if needed)
		| READI LPAREN RPAREN
		{: RESULT = new ReadIExpr(); :}

;

//Location. (meaning: some variable instance, variable field,
// member of array)
location ::= 

		//location: ID
		VAR:v
		{: RESULT = new VarExpr(v); :}
		
		//location: member access (the member "id" can be field, method etc.) 
		// syntax: expr '.' ID
		//| expr:ex DOT VAR:v
		|expr_dot: e VAR: v 
		
		//location: array subscript access
		// syntax: expr '[' expr ']'
		| expr:arr LB expr:subscript RB
		
;

 
//call
call ::=
staticCall:c
{:
RESULT = new Call(c);
System.out.println("Reduced rule virtualCall for Call =" + c); 
:}
| virtualCall:c
{:
RESULT = new Call(c);
System.out.println("Reduced rule virtualCall for Call =" + c); 
:}
;
composedExpr ::= |expr | expr COMMA composedExpr;

//virtuallCall
virtualCall ::=
LB expr: e1 DOT RB ID LPAREN LB composedExpr: e2 RB RPAREN  
{:
RESULT = new VirtualCall(e1, e2);
System.out.println("Reduced virtualCall for e1="+e1+"and e2="+e2);
:}
;

//staticCall
staticCall ::=
CLASS DOT ID LPAREN LB composedExpr RB RPAREN
{:
RESULT = StaticCall(exp);
System.out.println("Deduced staticCall for expression =",exp);
:}
| ID LPAREN LB composedExpr RB RPAREN
{:
RESULT = StaticCall(exp);
System.out.println("Deduced staticCall for expression =",exp);
:}

;
//binop
binop ::=
PLUS:op
{:
RESULT = Operator.PLUS
:}
 | MINUS:op
{:
RESULT = Operator.MINUS
:}
  | MULT:op
{:
RESULT = Operator.MULT
:}
  | DIV:op
{:
RESULT = Operator.DIV
:}
  | MOD:op
{:
RESULT = Operator.MOD
:}
 |  LAND:op
{:
RESULT = Operator.LAND
:}
  | LOR:op
{:
RESULT = Operator.LOR
:}
  | GT:op
{:
RESULT = Operator.GT
:}
  | GE:op
{:
RESULT = Operator.GE
:}
  | LT:op
{:
RESULT = Operator.LT
:}
  | LE:op
{:
RESULT = Operator.LE
:}
  | EQUAL:op
{:
RESULT = Operator.EQUAL
:}
  | NEQUAL: op
{:
RESULT = Operator.NEQUAL
:}
;

//unop
unop ::=
LNEG:op
{:
RESULT = new UnOp(op);
System.out.prinln("Reduced unop = "+op);
:}
| MINUS: op
{:
RESULT = new UnOp(op);
System.out.prinln("Reduced unop = "+op);
:}
;

//literal
//TODO: fix the rest of literals
literal ::=
		
		//number literal
		//example : 5
		NUMBER:n
		{: 
		RESULT = new NumberExpr(n.intValue()); 
		System.out.println("Reduced lit for num. literal = "+n);
		:}
		
		//string literal.
		//example : "banana"
		| QUOTE:lit
		{:
		RESULT = new Literal(lit);
		System.out.println("Reduced lit for lit = "+lit);
		:}
		
		 | TRUE: lit
		 {:
		RESULT = new Literal(lit);
		System.out.println("Reduced lit for lit = "+lit);
		:}
		  | FALSE:lit
		  {:
		RESULT = new Literal(lit);
		System.out.println("Reduced lit for lit = "+lit);
		:}
		   | NULL: lit 
		{:
		RESULT = new Literal(lit);
		System.out.println("Reduced lit for lit = "+lit);
		:}
		;
